/**
 * Theme Builder - CSS Converter
 * Functions for converting theme data to CSS formats
 * Extracted from ThemeEditor.tsx as part of Clean Architecture refactor
 */

import type { 
  ThemeData, 
  ColorValues,
  Typography,
  Breakpoint
} from '../../shared/types';

// ============================================================================
// CSS VARIABLE GENERATION
// ============================================================================

/**
 * Converts color values to CSS custom properties
 */
export function colorsToCSSVariables(colors: ColorValues | undefined): string {
  if (!colors || typeof colors !== 'object') {
    return '';
  }
  
  return Object.entries(colors)
    .map(([key, value]) => `  --${key}: ${value};`)
    .join('\n');
}

/**
 * Generates CSS variables for a complete theme
 */
export function generateThemeCSSVariables(theme: ThemeData): {
  light: string;
  dark: string;
} {
  // Support both new and legacy format
  const lightColors = theme.lightColors || theme.lightModeConfig || {};
  const darkColors = theme.darkColors || theme.darkModeConfig || {};
  
  const lightVars = colorsToCSSVariables(lightColors);
  const darkVars = colorsToCSSVariables(darkColors);
  
  return {
    light: lightVars,
    dark: darkVars
  };
}

// ============================================================================
// CSS FILE GENERATION
// ============================================================================

/**
 * Generates a complete CSS file from theme data
 */
export function generateCSSThemeFile(theme: ThemeData): string {
  const { name } = theme;
  
  // Support both new and legacy format
  const lightColors = theme.lightColors || theme.lightModeConfig || {};
  const darkColors = theme.darkColors || theme.darkModeConfig || {};
  
  let css = `/* ${name || 'Theme'} */\n`;
  css += `/* Generated by Alkitu Theme Builder */\n\n`;

  // Light mode variables
  css += ':root {\n';
  css += colorsToCSSVariables(lightColors);
  css += '\n}\n\n';

  // Dark mode variables using data attribute
  css += '[data-theme="dark"] {\n';
  css += colorsToCSSVariables(darkColors);
  css += '\n}\n\n';

  // Media query for system preference
  css += '@media (prefers-color-scheme: dark) {\n';
  css += '  :root:not([data-theme="light"]) {\n';
  css += colorsToCSSVariables(darkColors)
    .split('\n')
    .map(line => '  ' + line)
    .join('\n');
  css += '\n  }\n';
  css += '}\n';

  return css;
}

/**
 * Generates CSS with both custom properties and utility classes
 */
export function generateCSSWithUtilities(theme: ThemeData): string {
  let css = generateCSSThemeFile(theme);
  
  css += '\n/* Utility Classes */\n\n';
  
  // Color utilities
  const colorNames = Object.keys(theme.lightModeConfig);
  
  // Background utilities
  css += '/* Background Colors */\n';
  colorNames.forEach(color => {
    if (!color.includes('foreground')) {
      css += `.bg-${color} {\n`;
      css += `  background-color: var(--${color});\n`;
      css += '}\n';
    }
  });
  
  css += '\n/* Text Colors */\n';
  colorNames.forEach(color => {
    if (color.includes('foreground') || !colorNames.includes(`${color}-foreground`)) {
      const textColorName = color.replace('-foreground', '');
      css += `.text-${textColorName} {\n`;
      css += `  color: var(--${color});\n`;
      css += '}\n';
    }
  });
  
  css += '\n/* Border Colors */\n';
  colorNames.forEach(color => {
    if (!color.includes('foreground')) {
      css += `.border-${color} {\n`;
      css += `  border-color: var(--${color});\n`;
      css += '}\n';
    }
  });
  
  return css;
}

// ============================================================================
// TYPOGRAPHY CSS GENERATION
// ============================================================================

/**
 * Converts typography settings to CSS variables
 */
export function typographyToCSSVariables(typography: Typography): string {
  const vars: string[] = [];
  
  // Font families
  if (typography.fontFamily) {
    vars.push(`  --font-sans: ${typography.fontFamily};`);
  }
  if (typography.monoFontFamily) {
    vars.push(`  --font-mono: ${typography.monoFontFamily};`);
  }
  
  // Font sizes
  Object.entries(typography.fontSize).forEach(([size, value]) => {
    vars.push(`  --font-size-${size}: ${value};`);
  });
  
  // Line heights
  Object.entries(typography.lineHeight).forEach(([size, value]) => {
    vars.push(`  --line-height-${size}: ${value};`);
  });
  
  // Font weights
  Object.entries(typography.fontWeight).forEach(([weight, value]) => {
    vars.push(`  --font-weight-${weight}: ${value};`);
  });
  
  return vars.join('\n');
}

/**
 * Generates typography utility classes
 */
export function generateTypographyUtilities(typography: Typography): string {
  let css = '/* Typography Utilities */\n\n';
  
  // Font size utilities
  css += '/* Font Sizes */\n';
  Object.keys(typography.fontSize).forEach(size => {
    css += `.text-${size} {\n`;
    css += `  font-size: var(--font-size-${size});\n`;
    css += `  line-height: var(--line-height-${size});\n`;
    css += '}\n';
  });
  
  css += '\n/* Font Weights */\n';
  Object.keys(typography.fontWeight).forEach(weight => {
    css += `.font-${weight} {\n`;
    css += `  font-weight: var(--font-weight-${weight});\n`;
    css += '}\n';
  });
  
  css += '\n/* Font Families */\n';
  css += '.font-sans {\n';
  css += '  font-family: var(--font-sans);\n';
  css += '}\n';
  css += '.font-mono {\n';
  css += '  font-family: var(--font-mono);\n';
  css += '}\n';
  
  return css;
}

// ============================================================================
// RESPONSIVE CSS GENERATION
// ============================================================================

/**
 * Generates responsive CSS for breakpoint-specific values
 */
export function generateResponsiveCSS<T>(
  property: string,
  values: Partial<Record<Breakpoint, T>>,
  breakpoints: Record<Breakpoint, number>
): string {
  let css = '';
  
  const breakpointOrder: Breakpoint[] = ['mobile', 'tablet', 'desktop', 'tv'];
  
  breakpointOrder.forEach(breakpoint => {
    if (values[breakpoint] !== undefined) {
      if (breakpoint === 'mobile') {
        // Mobile-first approach - no media query needed
        css += `${property}: ${values[breakpoint]};\n`;
      } else {
        css += `@media (min-width: ${breakpoints[breakpoint]}px) {\n`;
        css += `  ${property}: ${values[breakpoint]};\n`;
        css += '}\n';
      }
    }
  });
  
  return css;
}

// ============================================================================
// CSS RULE GENERATION
// ============================================================================

/**
 * Generates CSS rules from theme configuration
 */
export function generateCSSRules(
  selector: string,
  properties: Record<string, string>
): string {
  const props = Object.entries(properties)
    .map(([key, value]) => `  ${key}: ${value};`)
    .join('\n');
  
  return `${selector} {\n${props}\n}\n`;
}

/**
 * Generates scoped CSS for theme preview
 */
export function generateScopedThemeCSS(
  theme: ThemeData,
  scopeSelector: string = '.theme-preview'
): string {
  let css = `/* Scoped Theme Preview */\n\n`;
  
  // Light mode
  css += `${scopeSelector} {\n`;
  css += colorsToCSSVariables(theme.lightModeConfig);
  css += '\n}\n\n';
  
  // Dark mode
  css += `${scopeSelector}[data-theme="dark"] {\n`;
  css += colorsToCSSVariables(theme.darkModeConfig);
  css += '\n}\n';
  
  return css;
}

// ============================================================================
// CSS PARSING
// ============================================================================

/**
 * Extracts CSS variables from CSS content
 */
export function extractCSSVariables(cssContent: string): Record<string, string> {
  const variables: Record<string, string> = {};
  const variableRegex = /--([^:]+):\s*([^;]+);/g;
  
  let match;
  while ((match = variableRegex.exec(cssContent)) !== null) {
    const [, name, value] = match;
    variables[name.trim()] = value.trim();
  }
  
  return variables;
}

/**
 * Parses CSS theme file into theme data
 */
export function parseCSSTheme(cssContent: string): {
  lightColors: Record<string, string>;
  darkColors: Record<string, string>;
} {
  const lightColors: Record<string, string> = {};
  const darkColors: Record<string, string> = {};

  // Extract CSS variables from :root
  const rootMatch = cssContent.match(/:root\s*{([^}]*)}/);
  if (rootMatch) {
    const rootContent = rootMatch[1];
    Object.assign(lightColors, extractCSSVariables(rootContent));
  }

  // Extract CSS variables from dark theme selectors
  const darkSelectors = [
    /\[data-theme="dark"\]\s*{([^}]*)}/,
    /:root\[data-theme="dark"\]\s*{([^}]*)}/,
    /@media\s*\(prefers-color-scheme:\s*dark\)\s*{\s*:root\s*{([^}]*)}/
  ];
  
  for (const selector of darkSelectors) {
    const match = cssContent.match(selector);
    if (match) {
      const darkContent = match[1];
      Object.assign(darkColors, extractCSSVariables(darkContent));
      break;
    }
  }

  // If no dark colors found, use light colors as fallback
  if (Object.keys(darkColors).length === 0) {
    Object.assign(darkColors, lightColors);
  }

  return { lightColors, darkColors };
}

// ============================================================================
// CSS MINIFICATION
// ============================================================================

/**
 * Minifies CSS content
 */
export function minifyCSS(css: string): string {
  return css
    // Remove comments
    .replace(/\/\*[\s\S]*?\*\//g, '')
    // Remove unnecessary whitespace
    .replace(/\s+/g, ' ')
    // Remove space around selectors
    .replace(/\s*([{}:;,])\s*/g, '$1')
    // Remove trailing semicolon before closing brace
    .replace(/;}/g, '}')
    // Remove leading/trailing whitespace
    .trim();
}

/**
 * Formats CSS content with proper indentation
 */
export function formatCSS(css: string): string {
  let formatted = css;
  let indentLevel = 0;
  
  // Add newlines and indentation
  formatted = formatted.replace(/([{}])/g, (match, char) => {
    if (char === '{') {
      const result = ` {\n${' '.repeat((indentLevel + 1) * 2)}`;
      indentLevel++;
      return result;
    } else {
      indentLevel = Math.max(0, indentLevel - 1);
      return `\n${' '.repeat(indentLevel * 2)}}`;
    }
  });
  
  // Format properties
  formatted = formatted.replace(/;/g, ';\n' + ' '.repeat(indentLevel * 2));
  
  // Clean up extra whitespace
  formatted = formatted.replace(/\n\s*\n/g, '\n');
  
  return formatted.trim();
}

// ============================================================================
// CSS CONVERTER CLASS
// ============================================================================

/**
 * CSS Converter class - provides both static and instance methods
 * for CSS generation and conversion
 */
export class CssConverter {
  // Static methods
  static colorsToCSSVariables = colorsToCSSVariables;
  static generateThemeCSSVariables = generateThemeCSSVariables;
  static generateCSSThemeFile = generateCSSThemeFile;
  static generateCSSWithUtilities = generateCSSWithUtilities;
  static typographyToCSSVariables = typographyToCSSVariables;
  static generateTypographyUtilities = generateTypographyUtilities;
  static generateResponsiveCSS = generateResponsiveCSS;
  static generateCSSRules = generateCSSRules;
  static generateScopedThemeCSS = generateScopedThemeCSS;
  static extractCSSVariables = extractCSSVariables;
  static parseCSSTheme = parseCSSTheme;
  static minifyCSS = minifyCSS;
  static formatCSS = formatCSS;

  // Instance methods for non-static usage
  colorsToCSSVariables = colorsToCSSVariables;
  generateThemeCSSVariables = generateThemeCSSVariables;
  generateCSSThemeFile = generateCSSThemeFile;
  generateCSSWithUtilities = generateCSSWithUtilities;
  typographyToCSSVariables = typographyToCSSVariables;
  generateTypographyUtilities = generateTypographyUtilities;
  generateResponsiveCSS = generateResponsiveCSS;
  generateCSSRules = generateCSSRules;
  generateScopedThemeCSS = generateScopedThemeCSS;
  extractCSSVariables = extractCSSVariables;
  parseCSSTheme = parseCSSTheme;
  minifyCSS = minifyCSS;
  formatCSS = formatCSS;

  // Convenience methods for common use cases
  generateCssVariables(themeData: any): string {
    if (!themeData) return '';
    
    if (themeData.lightColors && themeData.darkColors) {
      return generateCSSThemeFile(themeData);
    }
    
    // If it's just color values, convert them directly
    return colorsToCSSVariables(themeData);
  }

  generateScssVariables(themeData: any): string {
    if (!themeData) return '';
    
    const css = this.generateCssVariables(themeData);
    return css.replace(/--([a-zA-Z0-9-]+):\s*([^;]+);/g, '$$$1: $2;');
  }

  generateCssTypography(typography: any): string {
    if (!typography) return '';
    return typographyToCSSVariables(typography);
  }

  generateScssTypography(typography: any): string {
    if (!typography) return '';
    const css = this.generateCssTypography(typography);
    return css.replace(/--([a-zA-Z0-9-]+):\s*([^;]+);/g, '$$$1: $2;');
  }
}