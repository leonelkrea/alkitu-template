import { toast } from 'sonner';

// Types
export interface ThemeColors {
  [key: string]: string;
}

export interface ThemeData {
  name?: string;
  lightModeConfig: ThemeColors;
  darkModeConfig: ThemeColors;
}

// CSS variable pattern
const CSS_VAR_PATTERN = /^\s*--([\w-]+):\s*(.+?);?\s*$/;

// Color conversion utilities
function hslToOklch(hsl: string): string {
  // Simple conversion for demonstration - in production use a proper color library
  return hsl; // For now, return as-is
}

function rgbToOklch(rgb: string): string {
  // Simple conversion for demonstration - in production use a proper color library
  return rgb; // For now, return as-is
}

function hexToOklch(hex: string): string {
  // Simple conversion for demonstration - in production use a proper color library
  return hex; // For now, return as-is
}

// Parse CSS content and extract theme variables
export function parseCssTheme(cssContent: string): ThemeData | null {
  try {
    const lines = cssContent.split('\n');
    const lightColors: ThemeColors = {};
    const darkColors: ThemeColors = {};
    
    let currentMode: 'light' | 'dark' | null = null;
    
    for (const line of lines) {
      // Check for :root or .dark selectors
      if (line.includes(':root')) {
        currentMode = 'light';
        continue;
      }
      if (line.includes('.dark')) {
        currentMode = 'dark';
        continue;
      }
      
      // Extract CSS variables
      const match = line.match(CSS_VAR_PATTERN);
      if (match && currentMode) {
        const [, varName, value] = match;
        const cleanValue = value.trim().replace(/;$/, '');
        
        if (currentMode === 'light') {
          lightColors[varName] = cleanValue;
        } else {
          darkColors[varName] = cleanValue;
        }
      }
    }
    
    if (Object.keys(lightColors).length === 0 && Object.keys(darkColors).length === 0) {
      return null;
    }
    
    return {
      lightModeConfig: lightColors,
      darkModeConfig: Object.keys(darkColors).length > 0 ? darkColors : lightColors,
    };
  } catch (error) {
    console.error('Error parsing CSS theme:', error);
    return null;
  }
}

// Parse JSON theme file
export function parseJsonTheme(jsonContent: string): ThemeData | null {
  try {
    const data = JSON.parse(jsonContent);
    
    // Handle different JSON formats
    if (data.lightModeConfig && data.darkModeConfig) {
      // Our format
      return data as ThemeData;
    } else if (data.light && data.dark) {
      // Alternative format
      return {
        name: data.name,
        lightModeConfig: data.light,
        darkModeConfig: data.dark,
      };
    } else if (data.colors) {
      // Single mode format
      return {
        lightModeConfig: data.colors,
        darkModeConfig: data.colors,
      };
    } else {
      // Assume it's a flat color object
      return {
        lightModeConfig: data,
        darkModeConfig: data,
      };
    }
  } catch (error) {
    console.error('Error parsing JSON theme:', error);
    return null;
  }
}

// Import theme from file
export async function importThemeFromFile(file: File): Promise<ThemeData | null> {
  try {
    const content = await file.text();
    const fileName = file.name.toLowerCase();
    
    if (fileName.endsWith('.css')) {
      const theme = parseCssTheme(content);
      if (!theme) {
        toast.error('No valid CSS theme variables found');
        return null;
      }
      return theme;
    } else if (fileName.endsWith('.json')) {
      const theme = parseJsonTheme(content);
      if (!theme) {
        toast.error('Invalid JSON theme format');
        return null;
      }
      return theme;
    } else {
      toast.error('Unsupported file format. Please use .css or .json files');
      return null;
    }
  } catch (error) {
    console.error('Error importing theme:', error);
    toast.error('Failed to import theme file');
    return null;
  }
}

// Export theme to JSON
export function exportThemeToJson(theme: ThemeData): string {
  return JSON.stringify(theme, null, 2);
}

// Export theme to CSS
export function exportThemeToCss(theme: ThemeData): string {
  let css = '/* Theme generated by Alkitu Theme Editor */\n\n';
  
  // Light mode
  css += ':root {\n';
  Object.entries(theme.lightModeConfig).forEach(([key, value]) => {
    css += `  --${key}: ${value};\n`;
  });
  css += '}\n\n';
  
  // Dark mode
  css += '.dark {\n';
  Object.entries(theme.darkModeConfig).forEach(([key, value]) => {
    css += `  --${key}: ${value};\n`;
  });
  css += '}\n';
  
  return css;
}

// Validate theme colors
export function validateThemeColors(colors: ThemeColors): string[] {
  const errors: string[] = [];
  const requiredColors = [
    'background', 'foreground', 'primary', 'primary-foreground',
    'secondary', 'secondary-foreground', 'muted', 'muted-foreground',
    'accent', 'accent-foreground', 'destructive', 'destructive-foreground',
    'border', 'input', 'ring'
  ];
  
  for (const required of requiredColors) {
    if (!colors[required]) {
      errors.push(`Missing required color: ${required}`);
    }
  }
  
  return errors;
}